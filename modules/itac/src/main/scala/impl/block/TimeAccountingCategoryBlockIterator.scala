// Copyright (c) 2016-2025 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package edu.gemini.tac.qengine.impl.block

import edu.gemini.tac.qengine.p1.Observation
import edu.gemini.tac.qengine.p1.Proposal
import edu.gemini.tac.qengine.util.Time

/**
 * An iterator, of sorts, which can be used to step through a single list of
 * proposals generating TimeBlock instances.  The proposals are expected to be
 * associated with a single TimeAccountingCategory (hence the name of the class), but nothing
 * enforces this.
 *
 * <p>Unless the hasNext method returns <code>true</code>, the results of
 * calling any other method are unspecified.
 */
trait TimeAccountingCategoryBlockIterator{

  /**
   * Remaining proposals that have not yet been completely visited.
   */
  def remainingProposals: List[Proposal]

  /**
   * The proposal that will be referenced from the TimeBlock that is generated
   * by the 'next' method.
   */
  def currentProposal: Proposal = remainingProposals.head


   /**
   * Observations in the current proposal that have not been completely visited.
   */
  def remainingObservationsInActiveList: List[Observation]

  /**
   * The observation that will be referenced from the TimeBlock that is
   * generated by the 'next' method.
   */
  def currentObservation: Observation = remainingObservationsInActiveList.head

  /**
   * The amount of time in the current observation which has not be assigned
   * to any TimeBlock
   */
  def currentObservationRemainingTime: Time

  /**
   * Whether this iterator's next method will generate the first block of the
   * current proposal.
   */
  def isStartBlock: Boolean

  /**
   * Determines whether this iterator will generate a TimeBlock if the `next`
   * method is called.  No other methods should be called if this method
   * returns <code>false</code>.
   */
  def hasNext = !remainingProposals.isEmpty


  def isStartOf(prop: Proposal): Boolean =
    (currentProposal.id == prop.id) && isStartBlock

  private def nextBlock(maxTime: Time): Block = {
    val time = Time.min(currentObservationRemainingTime, maxTime)
    val isFinal = (remainingObservationsInActiveList.tail == Nil) && (time == currentObservationRemainingTime)
    Block(currentProposal, currentObservation, time, isStartBlock, isFinal)
  }

  /**
   * Generates the next TimeBlock and the next TimeAccountingCategoryTimeBlockIterator.
   */
  def next(maxTime: Time, activeList : Proposal => List[Observation]): (Block, TimeAccountingCategoryBlockIterator) = {
    val block = nextBlock(maxTime)
    (block, advance(block.time, activeList))
  }

  /**
   * Generates a TimeAccountingCategoryTimeBlock iterator for the next proposal, skipping the
   * current proposal and its observations.
   */
  def skip(activeList : Proposal => List[Observation]): TimeAccountingCategoryBlockIterator = advanceProp(activeList)

  private def advanceProp(activeList : Proposal => List[Observation]): TimeAccountingCategoryBlockIterator = remainingProposals match {
    case _ :: nextProp :: tail =>
      mkIterator(nextProp :: tail, activeList(nextProp),
        Observation.relativeObsTime(activeList(nextProp).head, nextProp.time, activeList(nextProp)), isStartOfBlock = true)
    case _ => TimeAccountingCategoryBlockIterator.Empty
  }

  private def advanceObs(activeList : Proposal => List[Observation]): TimeAccountingCategoryBlockIterator = remainingObservationsInActiveList match {
    case _ :: nextObs :: tail =>
      mkIterator(remainingProposals, nextObs :: tail,
        Observation.relativeObsTime(nextObs, currentProposal.time, activeList(currentProposal)), isStartOfBlock = false)
    case _ => advanceProp(activeList)
  }

  private def advance(t: Time, activeList : Proposal => List[Observation]): TimeAccountingCategoryBlockIterator =
    if (currentObservationRemainingTime > t)
      mkIterator(remainingProposals, remainingObservationsInActiveList, currentObservationRemainingTime - t, isStartOfBlock = false)
    else
      advanceObs(activeList)

  protected def mkIterator(propList: List[Proposal], obsList: List[Observation], time: Time, isStartOfBlock: Boolean): TimeAccountingCategoryBlockIterator
}


/**
 * A factory for creating TimeAccountingCategoryTimeBlockIterators.
 */
object TimeAccountingCategoryBlockIterator {

  private object Empty extends TimeAccountingCategoryBlockIterator {
    val remainingProposals: List[Proposal] = Nil
    val remainingObservationsInActiveList: List[Observation] = Nil
    val currentObservationRemainingTime: Time = Time.Zero
    val isStartBlock: Boolean = false

    def mkIterator(propList: List[Proposal], obsList: List[Observation], time: Time, start: Boolean): TimeAccountingCategoryBlockIterator = this
  }

  private class NormalIterator(val remainingProposals: List[Proposal], val remainingObservationsInActiveList: List[Observation], val currentObservationRemainingTime: Time, val isStartBlock: Boolean) extends TimeAccountingCategoryBlockIterator {
    def mkIterator(propList: List[Proposal], obsList: List[Observation], time: Time, start: Boolean): TimeAccountingCategoryBlockIterator =
      new NormalIterator(propList, obsList, time, start)
  }

  private def init(l: List[Proposal], activeList : Proposal => List[Observation]): (List[Observation], Time) = {
    val activeProposal = l.head
    val activeObservations = activeList(activeProposal)
    val firstObservation = activeObservations.head
    (activeObservations, Observation.relativeObsTime(firstObservation, activeProposal.time, activeObservations))
  }

  private def applyNonEmpty(propList: List[Proposal], activeList : Proposal=>List[Observation]): TimeAccountingCategoryBlockIterator =
    init(propList, activeList) match {
      case (activeObservations, time) => new NormalIterator(propList, activeObservations, time, true)
    }

  /**
   * Creates a TimeAccountingCategoryTimeBlockIterator that uses times associated with the
   * specified category and steps through the given list of proposals.
   *
   * <p>Note, there is no input validation but it is expected that all the
   * proposals contain at least one observation.  If there are any proposals
   * without observations, expect runtime exceptions. The same is true when
   * using Band 3 times (that is, if activeList is _.band3Observations).
   * Please ensure that the proposal lists are filtered as
   * appropriate.
   */
  def apply(propList: List[Proposal], activeList : Proposal=>List[Observation]): TimeAccountingCategoryBlockIterator =
    if (propList.isEmpty) Empty else applyNonEmpty(propList, activeList)
}
