// Copyright (c) 2016-2025 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package lucuma.core.math

import cats.Eq
import cats.Show
import cats.implicits.*
import cats.kernel.laws.discipline.*
import lucuma.core.arb.ArbTime
import lucuma.core.math.arb.*
import lucuma.core.math.parser.EpochParsers
import lucuma.core.math.parser.EpochParsers.*
import lucuma.core.optics.laws.discipline.*
import lucuma.core.refined.auto.*
import monocle.law.discipline.PrismTests
import org.scalacheck.Arbitrary
import org.scalacheck.Prop.*

import java.time.Instant
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

final class EpochSuite extends munit.DisciplineSuite {
  import ArbEpoch.given
  import ArbTime.given

  // provide an Arbitrary[String] for the Prism tests.
  given Arbitrary[String] = Arbitrary(ArbEpoch.strings)

  // Laws
  checkAll("Epoch", OrderTests[Epoch].order)
  checkAll("fromString", PrismTests(Epoch.fromString))
  checkAll("fromStringNoScheme",
           FormatTests(Epoch.fromStringNoScheme)
             .formatWith(ArbEpoch.stringsNoScheme)(using Eq[String], ArbEpoch.arbJulianEpoch, Eq[Epoch])
  )

  test("Epoch.eq.natural") {
    forAll { (a: Epoch, b: Epoch) =>
      assertEquals(a.equals(b), Eq[Epoch].eqv(a, b))
    }
  }

  test("Epoch.show.natural") {
    forAll { (a: Epoch) =>
      assertEquals(a.toString, Show[Epoch].show(a))
    }
  }

  test("Epoch.until.identity") {
    forAll { (a: Epoch) =>
      assertEquals(a.untilEpochYear(a.epochYear), 0.0)
    }
  }

  test("Epoch.until.sanity") {
    forAll { (a: Epoch, s: Short) =>
      assertEqualsDouble(a.untilEpochYear(a.epochYear + s.toDouble), s.toDouble, 0.005)
    }
  }

  test("Epoch.until.sanity2") {
    forAll { (s: Epoch.Scheme, d1: LocalDateTime, d2: LocalDateTime) =>
      // the dates generated by ArbTime are between years 2000 and 2020 and are safe for this.
      val Δ1 = s.fromLocalDateTime(d1).get.untilLocalDateTime(d2)
      val Δ2 = s.fromLocalDateTime(d2).get.epochYear - s.fromLocalDateTime(d1).get.epochYear
      assertEqualsDouble(Δ1, Δ2, 0.005)
    }
  }

  test("epochLenientNoScheme") {
    assertEquals(epochLenientNoScheme.parseAll("2014.123").toOption,
                 Epoch.Julian.fromMilliyears(2014123.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("2014").toOption, Epoch.Julian.fromMilliyears(2014000.refined).some)
    assertEquals(epochLenientNoScheme.parseAll("2014.").toOption,
                 Epoch.Julian.fromMilliyears(2014000.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("2014.1").toOption,
                 Epoch.Julian.fromMilliyears(2014100.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("2014.092").toOption,
                 Epoch.Julian.fromMilliyears(2014092.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("2014.002").toOption,
                 Epoch.Julian.fromMilliyears(2014002.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("J2014.123").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014.").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014.1").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.123").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.1").toOption, None)
  }

  test("epochFormatNoScheme") {
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014123.refined)),
                 "2014.123"
    )
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014000.refined)), "2014")
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014300.refined)),
                 "2014.3"
    )
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014092.refined)),
                 "2014.092"
    )
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014002.refined)),
                 "2014.002"
    )
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014350.refined)),
                 "2014.35"
    )
  }

  test("J2000 epoch should convert to correct Instant"):
    val j2000 = Epoch.J2000
    val instant = j2000.toInstant

    // J2000 converts to exactly noon UTC on Jan 1, 2000
    assertEquals(instant, Instant.parse("2000-01-01T12:00:00Z"))

  test("B1950 epoch convert to Instant"):
    val b1950 = Epoch.B1950
    val instant = b1950.toInstant

    // B1950 conversion  matches astropy
    val expected = Instant.parse("1949-12-31T22:09:46.861Z")
    assertEquals(instant.truncatedTo(ChronoUnit.MILLIS), expected.truncatedTo(ChronoUnit.MILLIS))

  test("Custom Julian epoch"):
    val epoch = Epoch.Julian.fromIntegralYears(2020.refined[Epoch.Year])
    val instant = epoch.toInstant

    val expected = Instant.parse("2020-01-01T12:00:00Z")
    assertEquals(instant, expected)

  test("Besselian epoch should match"):
    val epoch = Epoch.Besselian.fromIntegralYears(1950.refined[Epoch.Year])
    val instant = epoch.toInstant

    val b1950 = Epoch.B1950.toInstant
    assertEquals(instant, b1950)

  test("Fractional epoch year"):
    val epoch = Epoch.Julian.fromEpochYears(2020.5).get
    val instant = epoch.toInstant

    // 2020.5 Julian epoch converts to july 2nd assuming a year of 365.25 per definition
    val expected = Instant.parse("2020-07-02T03:00:00Z")
    assertEquals(instant, expected)

  test("formatWithScheme.exactly 2 decimal places"):
    forAll(ArbEpoch.epochs2Decimal): epoch =>
      val formatted = Epoch.formatWithScheme(epoch)
      assert(formatted.matches("""^[JB]\d+\.\d{2}$"""))

  test("January 1st test"):
    val testCases = List(
      (2012, "J2012"),
      (2013, "J2013.002"),
      (2014, "J2014.001"),
      (2015, "J2015"),
      (2016, "J2016"),
      (2017, "J2017.002"),
      (2018, "J2018.001"),
      (2019, "J2019"),
      (2020, "J2020"),
      (2021, "J2021.002"),
      (2022, "J2022.001"),
      (2023, "J2023"),
      (2024, "J2024"),
      (2025, "J2025.002"),
      (2026, "J2026.001"),
      (2027, "J2027")
    )

    testCases.foreach: (year, originalExpected) =>
      val ldt   = LocalDateTime.of(year, 1, 1, 0, 0, 0)
      val epoch = Epoch.Julian.fromLocalDateTime(ldt).get

      val format   = Epoch.formatWithScheme(epoch)
      val expected = s"J$year.00"

      assertEquals(format, expected)
      assertNotEquals(format, originalExpected)

      val parsedEpoch = Epoch.fromStringNoScheme.getOption(s"$year.00")
      assert(parsedEpoch.isDefined)

      val roundTripEpoch = EpochParsers.epochWithScheme.parseAll(format).toOption
      assert(roundTripEpoch.isDefined)
      assertEquals(Epoch.formatWithScheme(roundTripEpoch.get), format)

  test("December 31st tests"):
    val endOfYearDates = List(
      (LocalDateTime.of(2015, 12, 31, 23, 59, 59), "J2015.99"),
      (LocalDateTime.of(2016, 12, 31, 23, 59, 59), "J2016.99"),
      (LocalDateTime.of(2023, 12, 31, 23, 59, 59), "J2023.99"),
      (LocalDateTime.of(2024, 12, 31, 23, 59, 59), "J2024.99"),
      (LocalDateTime.of(2025, 12, 31, 23, 59, 59), "J2025.99")
    )

    endOfYearDates.foreach: (ldt, expected) =>
      val epoch     = Epoch.Julian.fromLocalDateTime(ldt).get
      val formatted = Epoch.formatWithScheme(epoch)

      assertEquals(formatted, expected)

      val roundTripEpoch = EpochParsers.epochWithScheme.parseAll(formatted).toOption
      assert(roundTripEpoch.isDefined)
      assertEquals(Epoch.formatWithScheme(roundTripEpoch.get), formatted)

  test("Edge cases around year boundaries"):
    val boundaryDates = List(
      (LocalDateTime.of(2024, 12, 31, 23, 59, 59), "J2024.99"),
      (LocalDateTime.of(2025, 1, 1, 0, 0, 0), "J2025.00"),
      (LocalDateTime.of(2024, 12, 31, 12, 0, 0), "J2024.99"),
      (LocalDateTime.of(2025, 1, 1, 12, 0, 0), "J2025.00"),
      (LocalDateTime.of(2025, 1, 2, 0, 0, 0), "J2025.00")
    )

    boundaryDates.foreach: (ldt, expected) =>
      val epoch     = Epoch.Julian.fromLocalDateTime(ldt).get
      val formatted = Epoch.formatWithScheme(epoch)

      assertEquals(formatted, expected)

      val roundTripEpoch = EpochParsers.epochWithScheme.parseAll(formatted).toOption
      assert(roundTripEpoch.isDefined)
      assertEquals(Epoch.formatWithScheme(roundTripEpoch.get), formatted)

}
