// Copyright (c) 2016-2025 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package lucuma.core.math

import cats.Eq
import cats.Show
import cats.implicits.*
import cats.kernel.laws.discipline.*
import lucuma.core.arb.ArbTime
import lucuma.core.math.arb.*
import lucuma.core.math.parser.EpochParsers.*
import lucuma.core.optics.laws.discipline.*
import lucuma.core.refined.auto.*
import monocle.law.discipline.PrismTests
import org.scalacheck.Arbitrary
import org.scalacheck.Prop.*

import java.time.Instant
import java.time.LocalDateTime
// import java.time.temporal.ChronoUnit

final class EpochSuite extends munit.DisciplineSuite {
  import ArbEpoch.given
  import ArbTime.given

  // provide an Arbitrary[String] for the Prism tests.
  given Arbitrary[String] = Arbitrary(ArbEpoch.strings)

  // Laws
  checkAll("Epoch", OrderTests[Epoch].order)
  checkAll("fromString", PrismTests(Epoch.fromString))
  checkAll(
    "fromStringNoScheme",
    FormatTests(Epoch.fromStringNoScheme).formatWith(ArbEpoch.stringsNoScheme)(using Eq[String], ArbEpoch.arbJulianEpoch, Eq[Epoch])
  )

  test("Epoch.eq.natural"):
    forAll { (a: Epoch, b: Epoch) =>
      assertEquals(a.equals(b), Eq[Epoch].eqv(a, b))
    }

  test("Epoch.show.natural"):
    forAll { (a: Epoch) =>
      assertEquals(a.toString, Show[Epoch].show(a))
    }

  test("Epoch.until.identity"):
    forAll { (a: Epoch) =>
      assertEquals(a.untilEpochYear(a.epochYear), 0.0)
    }

  test("Epoch.until.sanity"):
    forAll { (a: Epoch, s: Short) =>
      assertEqualsDouble(a.untilEpochYear(a.epochYear + s.toDouble), s.toDouble, 0.005)
    }

  test("Epoch.until.sanity2"):
    forAll { (s: Epoch.Scheme, d1: LocalDateTime, d2: LocalDateTime) =>
      // the dates generated by ArbTime are between years 2000 and 2020 and are safe for this.
      val Δ1 = s.fromUtcDateTime(d1).get.unsafeUntilUtcDateTime(d2)
      val Δ2 = s.fromUtcDateTime(d2).get.epochYear - s.fromUtcDateTime(d1).get.epochYear
      assertEqualsDouble(Δ1, Δ2, 0.005)
    }

  test("epochLenientNoScheme"):
    assertEquals(
      epochLenientNoScheme.parseAll("2014.123").toOption,
      Epoch.Julian.fromMilliyears(2014123.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("2014").toOption, Epoch.Julian.fromMilliyears(2014000.refined).some)
    assertEquals(
      epochLenientNoScheme.parseAll("2014.").toOption,
      Epoch.Julian.fromMilliyears(2014000.refined).some
    )
    assertEquals(
      epochLenientNoScheme.parseAll("2014.1").toOption,
      Epoch.Julian.fromMilliyears(2014100.refined).some
    )
    assertEquals(
      epochLenientNoScheme.parseAll("2014.092").toOption,
      Epoch.Julian.fromMilliyears(2014092.refined).some
    )
    assertEquals(
      epochLenientNoScheme.parseAll("2014.002").toOption,
      Epoch.Julian.fromMilliyears(2014002.refined).some
    )
    assertEquals(epochLenientNoScheme.parseAll("J2014.123").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014.").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("J2014.1").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.123").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.").toOption, None)
    assertEquals(epochLenientNoScheme.parseAll("B2014.1").toOption, None)

  test("epochFormatNoScheme") {
    assertEquals(
      Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014123.refined)),
      "2014.123"
    )
    assertEquals(Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014000.refined)), "2014")
    assertEquals(
      Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014300.refined)),
      "2014.3"
    )
    assertEquals(
      Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014092.refined)),
      "2014.092"
    )
    assertEquals(
      Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014002.refined)),
      "2014.002"
    )
    assertEquals(
      Epoch.fromStringNoScheme.reverseGet(Epoch.Julian.fromMilliyears(2014350.refined)),
      "2014.35"
    )
  }

  test("J2000 epoch should convert to correct Instant"):
    val j2000 = Epoch.J2000
    val instant = j2000.unsafeToInstant

    // J2000 converts to January 1, 2000 at 12:00 TT (2000-Jan-01 11:58:55.816 UTC)
    assertEquals(instant, Instant.parse("2000-01-01T11:58:55.816Z"))

  test("B1950 epoch convert to Instant"):
    val b1950 = Epoch.B1950
    val instant = b1950.unsafeToInstant

    // B1950 conversion matches astropy
    assertEquals(instant, Instant.parse("1949-12-31T22:09:46.861Z"))

  test("Custom Julian epoch"):
    val epoch = Epoch.Julian.unsafeFromIntYears(2020.refined[Epoch.Year])
    val instant = epoch.unsafeToInstant

    val expected = Instant.parse("2020-01-01T11:58:50.816Z")
    assertEquals(instant, expected)

  test("Besselian epoch should match"):
    val epoch = Epoch.Besselian.unsafeFromIntYears(1950.refined[Epoch.Year])
    val instant = epoch.unsafeToInstant

    val b1950 = Epoch.B1950.unsafeToInstant
    assertEquals(instant, b1950)

  test("Fractional epoch year"):
    val epoch = Epoch.Julian.unsafeFromEpochYears(2020.5)
    val instant = epoch.unsafeToInstant

    // 2020.5 Julian epoch converts to july 2nd assuming a year of 365.25 per definition
    val expected = Instant.parse("2020-07-02T02:58:50.816Z")
    assertEquals(instant, expected)

  test("January 1st test"): // Compared with astropy
    val testCases = List(
      (2012, "J2011.999"),
      (2013, "J2013.001"),
      (2014, "J2014.000"),
      (2015, "J2014.999"),
      (2016, "J2015.999"),
      (2017, "J2017.001"),
      (2018, "J2018.000"),
      (2019, "J2018.999"),
      (2020, "J2019.999"),
      (2021, "J2021.001"),
      (2022, "J2022.000"),
      (2023, "J2022.999"),
      (2024, "J2023.999"),
      (2025, "J2025.001"),
      (2026, "J2026.000"),
      (2027, "J2026.999")
    )

    testCases.foreach: (year, expected) =>
      val ldt: LocalDateTime   = LocalDateTime.of(year, 1, 1, 0, 0, 0)
      val epoch: Epoch = Epoch.Julian.unsafeFromUtcDateTime(ldt)

      assertEquals(Epoch.fromString.reverseGet(epoch), expected)

  test("December 31st tests"): // Compared with astropy
    val endOfYearDates = List(
      (LocalDateTime.of(2015, 12, 31, 23, 59, 59), "J2015.999"),
      (LocalDateTime.of(2016, 12, 31, 23, 59, 59), "J2017.001"),
      (LocalDateTime.of(2017, 12, 31, 23, 59, 59), "J2018.000"),
      (LocalDateTime.of(2018, 12, 31, 23, 59, 59), "J2018.999"),
      (LocalDateTime.of(2019, 12, 31, 23, 59, 59), "J2019.999"),
      (LocalDateTime.of(2020, 12, 31, 23, 59, 59), "J2021.001"),
      (LocalDateTime.of(2021, 12, 31, 23, 59, 59), "J2022.000"),
      (LocalDateTime.of(2022, 12, 31, 23, 59, 59), "J2022.999"),
      (LocalDateTime.of(2023, 12, 31, 23, 59, 59), "J2023.999"),
      (LocalDateTime.of(2024, 12, 31, 23, 59, 59), "J2025.001"),
      (LocalDateTime.of(2025, 12, 31, 23, 59, 59), "J2026.000")
    )

    endOfYearDates.foreach: (ldt, expected) =>
      val epoch: Epoch = Epoch.Julian.unsafeFromUtcDateTime(ldt)

      assertEquals(Epoch.fromString.reverseGet(epoch), expected)
}
